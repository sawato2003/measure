<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5.0,user-scalable=yes" />
<title>粗大ごみ寸法判定ツール（ズーム機能付）</title>
<style>
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN",
                 "Noto Sans JP", sans-serif;
    line-height: 1.6;
    margin: 0; /* マージンは内部ラッパーで管理 */
    background-color: #fff;
  }
  
  /* 拡大縮小対象のラッパー */
  #mainWrapper {
    padding: 16px;
    transform-origin: top left;
  }

  h1{ font-size:1.25rem; margin:0 0 8px; }
  .panel{
    border:1px solid #ddd;
    border-radius:8px;
    padding:12px;
    margin-bottom:16px;
    background: #fff;
  }
  .row{
    display:flex;
    flex-direction: column;
    gap:12px;
  }
  .col{ flex:1 1 320px; }
  canvas{
    width:100%;
    height:auto;
    max-width:100%;
    border:1px dashed #bbb;
    border-radius:6px;
    background:#f8f8f8;
    touch-action:none; 
  }
  button,input[type="file"]{
    padding:6px 10px;
    font-size:13px;
    margin:2px 4px 2px 0;
  }
  .btn-row{
    margin-top:4px;
    margin-bottom:4px;
    display:flex;
    flex-wrap:wrap;
    gap:4px;
  }
  .muted{ color:#666; font-size:0.9em; }
  .pill{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    background:#eee;
    margin-left:6px;
    font-size:0.8em;
  }
  .result{ font-size:1.0rem; padding:4px 0; }
  .hint{ font-size:0.9em; color:#444; }
  .small{ font-size:0.85em; color:#555; }
  .grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
  @media (max-width:900px){ .grid{ grid-template-columns:1fr; } }

  /* --- 右下のフローティング操作盤のスタイル --- */
  #zoomControls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .zoom-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 123, 255, 0.9);
    color: white;
    font-size: 24px;
    font-weight: bold;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.1s, background-color 0.2s;
  }
  .zoom-btn:active {
    transform: scale(0.95);
    background-color: #0056b3;
  }
  .zoom-btn.reset {
    font-size: 16px;
    background-color: rgba(108, 117, 125, 0.9);
  }
</style>
</head>
<body>

<div id="mainWrapper">

  <h1>粗大ごみ寸法判定ツール（10cmスケール紙＋画像）</h1>
  <p class="muted">
    10cmスケール紙と一緒に撮った写真から、<b>W（幅）+D（奥行）+H（高さ）</b>を求めて判定します。<br>
    ※右下のボタンで画面全体を拡大・縮小できます。細かい点の指定時にご活用ください。
  </p>

  <div class="grid">
    <div class="panel">
      <h2>① 上からの写真（幅W＋奥行D）<span class="pill">top</span></h2>
      <input type="file" id="topFile" accept="image/*" />
      <div class="btn-row">
        <button id="topScale">スケール指定（10cmの両端をタップ×2）</button>
        <button id="topAuto">自動抽出</button>
        <button id="topManual">手動で矩形</button>
      </div>
      <div class="row">
        <div class="col">
          <canvas id="topCanvas" width="640" height="480"></canvas>
          <div class="small">
            使い方：<br>
            1) スケール紙の10cm目盛の両端を2点タップ（青線）<br>
            2) 「自動抽出」か「手動で矩形」で物体を囲むとW,Dが出ます。<br>
            ※矩形は指でドラッグして描きます。
          </div>
        </div>
        <div class="col">
          <div class="result" id="topInfo">W=? mm / D=? mm / scale=? mm/px</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>② 横からの写真（高さH）<span class="pill">side</span></h2>
      <input type="file" id="sideFile" accept="image/*" />
      <div class="btn-row">
        <button id="sideScale">スケール指定（10cmの両端をタップ×2）</button>
        <button id="sideAuto">自動抽出</button>
        <button id="sideManual">手動で矩形</button>
      </div>
      <div class="row">
        <div class="col">
          <canvas id="sideCanvas" width="640" height="480"></canvas>
          <div class="small">
            使い方は上と同じ。<br>
            物体の高さ方向（床〜上端）を覆うように赤い枠で囲んでください。
          </div>
        </div>
        <div class="col">
          <div class="result" id="sideInfo">H=? mm / scale=? mm/px</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>③ 結果（W + D + H）と区分</h2>
    <div id="summary" class="result">未計算</div>
    <div class="hint">
      分類基準：
      <code>1: &lt;1500mm</code> /
      <code>2: 1500–1999mm</code> /
      <code>3: 2000–2499mm</code> /
      <code>4: ≥2500mm</code>
    </div>
  </div>

  <p class="muted">
    撮影のコツ：スケール紙はできれば平らに。なるべく真正面・真上に近い角度から撮り、少し離れてズームすると精度が安定します。
  </p>

</div> <div id="zoomControls">
  <button class="zoom-btn" id="btnZoomIn" title="拡大">＋</button>
  <button class="zoom-btn" id="btnZoomOut" title="縮小">－</button>
  <button class="zoom-btn reset" id="btnZoomReset" title="リセット">⟲</button>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="cvReady()"></script>
<script>
var REAL_LEN_MM = 100; // 10cm = 100mm 基準
function $(id){ return document.getElementById(id); }

// ビューごとの状態
var S = {
  top:  { bg:null, mode:"idle", clicks:[], rect:null, scale:null, W:null, D:null, scalePoints:[] },
  side: { bg:null, mode:"idle", clicks:[], rect:null, scale:null, H:null, scalePoints:[] }
};

function cvReady(){
  console.log("OpenCV.js loaded");
}

/* ----------------------------------------------------------
   ズーム機能の実装
   ---------------------------------------------------------- */
var currentZoom = 1.0;
var zoomStep = 0.2;
var wrapper = $("mainWrapper");

// CSSのzoomプロパティ(Chrome/Safari等)とtransform(Firefox等)を使い分け
function applyZoom(){
  // ブラウザがzoomプロパティをサポートしている場合（推奨：レイアウト崩れにくい）
  if ('zoom' in document.body.style) {
    wrapper.style.zoom = currentZoom;
  } else {
    // Firefoxなどのフォールバック
    wrapper.style.transform = "scale(" + currentZoom + ")";
    // transformの場合、余白が大きくなることがあるためwidth調整が必要な場合があるが、簡易実装とする
  }
}

$("btnZoomIn").onclick = function(){
  currentZoom += zoomStep;
  if(currentZoom > 3.0) currentZoom = 3.0; // 最大3倍
  applyZoom();
};

$("btnZoomOut").onclick = function(){
  currentZoom -= zoomStep;
  if(currentZoom < 0.6) currentZoom = 0.6; // 最小0.6倍
  applyZoom();
};

$("btnZoomReset").onclick = function(){
  currentZoom = 1.0;
  applyZoom();
};

/* ----------------------------------------------------------
   以下、元のCanvas/計測ロジック
   ---------------------------------------------------------- */

function loadToCanvas(file, canvasId, kind){
  if(!file){ alert("画像ファイルが取得できませんでした"); return; }
  var canvas = $(canvasId);
  var ctx = canvas.getContext("2d");
  var img = new Image();

  img.onload = function(){
    var maxW = canvas.width, maxH = canvas.height;
    var w = img.naturalWidth, h = img.naturalHeight;
    var s = Math.min(maxW/w, maxH/h);
    var dw = Math.round(w*s), dh = Math.round(h*s);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0,dw,dh);

    S[kind].bg = ctx.getImageData(0,0,canvas.width,canvas.height);
    S[kind].mode = "idle";
    S[kind].clicks = [];
    S[kind].rect = null;
    S[kind].scale = null;
    S[kind].scalePoints = [];
    if(kind==="top"){ S.top.W=null; S.top.D=null; updateInfo("top"); }
    else{ S.side.H=null; updateInfo("side"); }
    drawOverlay(kind);
  };

  var reader = new FileReader();
  reader.onload = function(e){ img.src = e.target.result; };
  reader.onerror = function(){ alert("画像の読み込みに失敗しました"); };
  reader.readAsDataURL(file);
}

function drawOverlay(kind){
  var canvas = $(kind+"Canvas");
  var ctx = canvas.getContext("2d");
  var st = S[kind];
  if(st.bg){
    ctx.putImageData(st.bg,0,0);
  }else{
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  var points = (st.mode==="scale" && st.clicks.length>0) ? st.clicks : st.scalePoints;
  if(points && points.length>0){
    ctx.strokeStyle="#2b74ff";
    ctx.fillStyle="#2b74ff";
    ctx.lineWidth=2;
    for(var i=0;i<points.length;i++){
      var p = points[i];
      ctx.beginPath();
      ctx.arc(p.x,p.y,4,0,Math.PI*2);
      ctx.fill();
    }
    if(points.length===2){
      var a=points[0], b=points[1];
      ctx.beginPath();
      ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
  }

  if(st.rect){
    ctx.strokeStyle="#ff3b30";
    ctx.lineWidth=2;
    ctx.strokeRect(st.rect.x, st.rect.y, st.rect.w, st.rect.h);
  }
}

function commitScale(kind){
  var st = S[kind];
  if(st.clicks.length !== 2){ alert("10cmスケールの両端を2点タップしてください"); return; }
  var a=st.clicks[0], b=st.clicks[1];
  var dpx = Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2));
  if(dpx<=0){ alert("距離が0です。"); return; }
  st.scale = REAL_LEN_MM / dpx; 
  st.scalePoints = [ {x:a.x,y:a.y}, {x:b.x,y:b.y} ];
  st.clicks = [];
  st.mode   = "idle";
  drawOverlay(kind);
  updateInfo(kind);
}

function applyManualRect(kind){
  var st = S[kind];
  if(!st.rect){ alert("先に矩形を描いてください"); return; }
  if(!st.scale){ alert("先にスケール指定をしてください"); return; }
  var mmPerPx = st.scale;
  if(kind==="top"){
    st.W = st.rect.w * mmPerPx;
    st.D = st.rect.h * mmPerPx;
  }else{
    st.H = st.rect.h * mmPerPx;
  }
  updateInfo(kind);
}

function autoExtract(kind){
  var st = S[kind];
  if(!st.scale){ alert("先にスケール指定をしてください"); return; }
  var canvas = $(kind+"Canvas");
  var ctx = canvas.getContext("2d");
  var imgData = st.bg || ctx.getImageData(0,0,canvas.width,canvas.height);
  var src = cv.matFromImageData(imgData);
  var gray = new cv.Mat(), blur = new cv.Mat(), thr = new cv.Mat();
  var kernel = cv.Mat.ones(3,3,cv.CV_8U);
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
  cv.adaptiveThreshold(blur, thr, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                       cv.THRESH_BINARY_INV, 21, 5);
  cv.morphologyEx(thr, thr, cv.MORPH_OPEN, kernel);
  var contours = new cv.MatVector();
  var hierarchy = new cv.Mat();
  cv.findContours(thr, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  if(contours.size()===0){
    cleanup(); alert("輪郭が見つかりませんでした"); return;
  }
  var maxIdx=0, maxArea=0;
  for(var i=0;i<contours.size();i++){
    var a = cv.contourArea(contours.get(i));
    if(a>maxArea){ maxArea=a; maxIdx=i; }
  }
  var cnt = contours.get(maxIdx);
  var rect = cv.boundingRect(cnt);
  st.rect = { x:rect.x, y:rect.y, w:rect.width, h:rect.height };
  cleanup();
  applyManualRect(kind);
  drawOverlay(kind);

  function cleanup(){
    src.delete(); gray.delete(); blur.delete(); thr.delete();
    kernel.delete(); contours.delete(); hierarchy.delete();
  }
}

function updateInfo(kind){
  if(kind==="top"){
    var st=S.top;
    var txt = "W=" + (st.W?st.W.toFixed(1):"?") + " mm / " +
              "D=" + (st.D?st.D.toFixed(1):"?") + " mm / " +
              "scale=" + (st.scale?st.scale.toFixed(4):"?") + " mm/px";
    $("topInfo").textContent = txt;
  }else{
    var st2=S.side;
    var txt2 = "H=" + (st2.H?st2.H.toFixed(1):"?") + " mm / " +
               "scale=" + (st2.scale?st2.scale.toFixed(4):"?") + " mm/px";
    $("sideInfo").textContent = txt2;
  }
  summarize();
}

function summarize(){
  var W=S.top.W||0, D=S.top.D||0, H=S.side.H||0;
  var sumElem = $("summary");
  if(!(W && D && H)){ sumElem.textContent = "未計算"; return; }
  var T = W + D + H;
  var cls = 4;
  if(T < 1500) cls=1;
  else if(T < 2000) cls=2;
  else if(T < 2500) cls=3;

  var N10 = (T / 100).toFixed(1);
  sumElem.innerHTML = "合計: <b>" + T.toFixed(1) + " mm</b> / 10cm換算: <b>" +
             N10 + "本</b><br>区分: <b>" + cls + "</b>";
}

function getCanvasPoint(ev, canvas){
  // 拡大縮小されていても、getBoundingClientRectは見た目のサイズを返すため
  // 正しく補正されます。
  var rect = canvas.getBoundingClientRect();
  var clientX, clientY;
  if(ev.touches && ev.touches.length>0){
    clientX = ev.touches[0].clientX;
    clientY = ev.touches[0].clientY;
  }else{
    clientX = ev.clientX;
    clientY = ev.clientY;
  }
  var scaleX = canvas.width  / rect.width;
  var scaleY = canvas.height / rect.height;
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top)  * scaleY
  };
}

function setupCanvasEvents(kind){
  var canvas = $(kind+"Canvas");
  var st = S[kind];
  var dragging = false, dragStart=null;

  canvas.addEventListener("click", function(ev){
    if(st.mode!=="scale") return;
    var p = getCanvasPoint(ev, canvas);
    st.clicks.push(p);
    if(st.clicks.length>2) st.clicks.shift();
    drawOverlay(kind);
    if(st.clicks.length===2){ commitScale(kind); }
  }, false);

  canvas.addEventListener("mousedown", function(ev){
    if(st.mode!=="manual") return;
    dragging = true;
    dragStart = getCanvasPoint(ev, canvas);
  }, false);

  canvas.addEventListener("mousemove", function(ev){
    if(!dragging || st.mode!=="manual") return;
    var cur = getCanvasPoint(ev, canvas);
    st.rect = {
      x: Math.min(dragStart.x,cur.x), y: Math.min(dragStart.y,cur.y),
      w: Math.abs(dragStart.x-cur.x), h: Math.abs(dragStart.y-cur.y)
    };
    drawOverlay(kind);
  }, false);

  canvas.addEventListener("mouseup", function(){
    if(dragging && st.mode==="manual"){
      dragging = false; applyManualRect(kind); drawOverlay(kind);
    }
  }, false);
  
  canvas.addEventListener("mouseleave", function(){
    if(dragging && st.mode==="manual"){
      dragging = false; applyManualRect(kind); drawOverlay(kind);
    }
  }, false);

  canvas.addEventListener("touchstart", function(ev){
    if(st.mode!=="manual") return;
    ev.preventDefault();
    dragging = true;
    dragStart = getCanvasPoint(ev, canvas);
  }, {passive:false});

  canvas.addEventListener("touchmove", function(ev){
    if(!dragging || st.mode!=="manual") return;
    ev.preventDefault();
    var cur = getCanvasPoint(ev, canvas);
    st.rect = {
      x: Math.min(dragStart.x,cur.x), y: Math.min(dragStart.y,cur.y),
      w: Math.abs(dragStart.x-cur.x), h: Math.abs(dragStart.y-cur.y)
    };
    drawOverlay(kind);
  }, {passive:false});

  canvas.addEventListener("touchend", function(ev){
    if(dragging && st.mode==="manual"){
      ev.preventDefault();
      dragging = false; applyManualRect(kind); drawOverlay(kind);
    }
  }, {passive:false});
}

document.addEventListener("DOMContentLoaded", function(){
  $("topFile").addEventListener("change", function(e){
    var file = e.target.files && e.target.files[0];
    if(file) loadToCanvas(file, "topCanvas", "top");
  }, false);
  $("sideFile").addEventListener("change", function(e){
    var file = e.target.files && e.target.files[0];
    if(file) loadToCanvas(file, "sideCanvas", "side");
  }, false);

  $("topScale").onclick  = function(){ S.top.mode="scale"; S.top.clicks=[]; S.top.scalePoints=[]; drawOverlay("top"); };
  $("sideScale").onclick = function(){ S.side.mode="scale"; S.side.clicks=[]; S.side.scalePoints=[]; drawOverlay("side"); };
  $("topManual").onclick = function(){ S.top.mode="manual"; S.top.rect=null; drawOverlay("top"); };
  $("sideManual").onclick = function(){ S.side.mode="manual"; S.side.rect=null; drawOverlay("side"); };
  $("topAuto").onclick = function(){ autoExtract("top"); };
  $("sideAuto").onclick = function(){ autoExtract("side"); };

  setupCanvasEvents("top");
  setupCanvasEvents("side");
}, false);
</script>
</body>
</html>
